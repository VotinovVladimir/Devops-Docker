# Docker

## Часть 1. Готовый докер

После установки linux на Virtualbox решил сразу пробросить порты 80, 443 и для подключения по ssh 22 порт

![1757847832916](images/report/1757847832916.png)

Подключаюсь к linux по ssh

![1757847944610](images/report/1757847944610.png)

Скачал официальный докер-образ с **nginx** при помощи `docker pull`.

![1757847515996](images/report/1757847515996.png)

Проверил наличие докер-образа через `docker images`.

![1757847562010](images/report/1757847562010.png)

Запустил докер-образ через `docker run -d [image_id|repository]`.

![1757847627868](images/report/1757847627868.png)

Проверил, что образ запустился через `docker ps`.

![1757847666591](images/report/1757847666591.png)

Нужно посмотреть информацию о контейнере через `docker inspect [container_id|container_name]`. По выводу команды определить размер контейнера, список замапленных портов и ip контейнера. Размер `docker ps -s`

![1757848427246](images/report/1757848427246.png)

`sudo docker inspect f0cd83c609a4` Видим IP Adress 172.17.0.2

![1757848548593](images/report/1757848548593.png)

`"80/tcp": null` в выводе `docker inspect` означает, что порт 80 контейнера НЕ замаплен (не проброшен) на порт хост-машины. Просто слушает порт 80 внутри контейнера.

![1757848618145](images/report/1757848618145.png)

Остановил докер контейнер через `sudo docker stop f0cd83c609a4`. Проверил, что контейнер остановился через `sudo docker ps`.

![1757849375900](images/report/1757849375900.png)

Запустил докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду *run*. Дал имя part1, чтобы самому не запутаться в контейнерах.

![1757850079358](images/report/1757850079358.png)

Проверил, что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**.

![1757850163314](images/report/1757850163314.png)

Перезапустил докер контейнер через `sudo docker restart dbc0253532e5`. Проверил, что контейнер запустился

![1757850336688](images/report/1757850336688.png)

## Часть 2. Операции с контейнером

Остановил предыдущий контейнер из части 1, чтобы он не занимал порты, запустил новый с именем part2

![1757852601331](images/report/1757852601331.png)

Прочитал конфигурационный файл *nginx.conf* внутри докер контейнера через команду *exec*.

`sudo docker exec -it part2 cat etc/nginx/nginx.conf`

![1757852911929](images/report/1757852911929.png)

Создал на локальной машине файл *nginx.conf*.

![1757854387920](images/report/1757854387920.png)

Скопировал созданный файл *nginx.conf* внутрь докер-образа через команду `docker cp`.

` sudo docker cp nginx.conf f60eac816915:etc/nginx/nginx.conf`

![1757854559248](images/report/1757854559248.png)

Перезапустил nginx внутри докер образа через команду exec

`sudo docker exec f60eac816915 nginx - s reload`

![1757854738546](images/report/1757854738546.png)

Проверил, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.

**`accepts` (10)** — общее количество **принятых** соединений с момента запуска Nginx.

**`handled` (10)** — количество **успешно обработанных** соединений.

**`requests` (11)** — общее количество **обработанных HTTP-запросов**.

![1757855012596](images/report/1757855012596.png)

Чтобы каждый раз не писать sudo применяем команды

`sudo groupadd docker`

`sudo usermod -aG docker brittanb`

`newgrp docker`

перезагрузить виртуалку

Экспортировал контейнер в файл *container.tar* через команду *export*.

`docker export f60eac816915 > container.tar`

![1757858425212](images/report/1757858425212.png)

Остановил контейнер

![1757858862640](images/report/1757858862640.png)

*Нельзя удалить образ, если он используется контейнером (даже остановленным)*

![1757859543173](images/report/1757859543173.png)

Удалил контейнеры `docker rm`

![1757859337385](images/report/1757859337385.png)

![1757859564570](images/report/1757859564570.png)

![1757859604947](images/report/1757859604947.png)

Удалил образ через `docker rmi [image_id|repository]`

![1757859647689](images/report/1757859647689.png)

Импортировал контейнер обратно через команду *import*.

![1757859797407](images/report/1757859797407.png)

Запусти импортированный контейнер.

* `nginx` — запускает веб-сервер
* `-g "daemon off;"` — запускает nginx в foreground режиме (обязательно для Docker). Без этого флага nginx запустится в фоне и контейнер сразу завершится

![1757860091049](images/report/1757860091049.png)

Проверил, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.

![1757860163203](images/report/1757860163203.png)

## Part 3. Мини веб-сервер

Нужно написать мини-сервер на **C** и **FastCgi**, который будет возвращать простейшую страничку с надписью `Hello World!`. Он есть в папке materials

![1757865532548](images/report/1757865532548.png)

Нужно написать свой *nginx.conf*, который будет проксировать все запросы с 81 порта на *127.0.0.1:8080*.

![1757863452226](images/report/1757863452226.png)

Запускаем nginx на порт 81

![1757863935435](images/report/1757863935435.png)

Переходим в папку 3 части, копируем файлы в docker контейнер

![1757864209503](images/report/1757864209503.png)

Заходим в контейнер

![1757864299354](images/report/1757864299354.png)

Устанавливаем spawn-fcgi

![1757864424565](images/report/1757864424565.png)

устанавливаем libfcgi-dev

![1757864530617](images/report/1757864530617.png)

устанавливаем gcc

![1757864585138](images/report/1757864585138.png)

компилируем файл

![1757864711378](images/report/1757864711378.png)

запускаем spawn-fcgi. Без `&` терминал будет заблокирован до завершения программы

![1757864743075](images/report/1757864743075.png)

перезапускаем nginx

![1757864884410](images/report/1757864884410.png)

проверяем нашу страничку

![1757865315145](images/report/1757865315145.png)

## Part 4. Свой докер

Создадим свой образ

![1757866039864](images/report/1757866039864.png)

из папки 04 выполняем команду `docker build -t my-fastcgi-server:part4 . `

![1757867726981](images/report/1757867726981.png)

Запусти собранный докер-образ с маппингом 81 порта на 80 на локальной машине и маппингом папки *./nginx* внутрь контейнера по адресу, где лежат конфигурационные файлы **nginx**'а

![1757867832751](images/report/1757867832751.png)

Проверил, что по localhost:80 доступна страничка написанного мини сервера.

![1757866578568](images/report/1757866578568.png)

Дописал в *./nginx/nginx.conf* проксирование странички */status*, по которой надо отдавать статус сервера **nginx**.

![1757866827657](images/report/1757866827657.png)

Перезапустил докер-образ.

![1757868755699](images/report/1757868755699.png)

Проверил, что теперь по *localhost:80/status* отдается страничка со статусом **nginx**

![1757868743584](images/report/1757868743584.png)

## Part 5. **Dockle**

Просканируй образ из предыдущего задания через `dockle [image_id|repository]`.

с помощью команды docker run --rm -v /var/run/docker.sock:/var/run/docker.sock goodwithtech/dockle my-fastcgi-server:1.0 проверяем образ

![1757868903961](images/report/1757868903961.png)

Исправляем образ, используем образ alpine. Переписываем под alpine команды, прописываем healtcheck

![1757869144239](images/report/1757869144239.png)

Собираем образ заново

![1757869321205](images/report/1757869321205.png)

![1757869344434](images/report/1757869344434.png)

Эта информация гласит, что я проверяю образом который не имеет подписи, к нашему образу это не относится

**Образ `fastcgi-server:part4` прошел проверку** - критических уязвимостей нет

Dockle рекомендует включить **Content Trust** для повышения безопасности

включается командой `export DOCKER_CONTENT_TRUST=1`

## Part 6. Базовый **Docker Compose**

1. **fastcgi-app** слушает порт 81 во внутренней сети
2. **nginx-proxy** проксирует с порта 8080 на fastcgi-app:81
3. Порт 8080 nginx-proxy мапится на порт 80 хоста

Написал файл *docker-compose.yml*

![1757870243637](images/report/1757870243637.png)

создаем конфиг для сервер проксирования с 8080 на 81 порт

![1757870503032](images/report/1757870503032.png)

![1757871439536](images/report/1757871439536.png)

![1757871415495](images/report/1757871415495.png)
